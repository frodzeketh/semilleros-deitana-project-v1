
// =====================================
// IMPORTACIONES Y CONFIGURACI√ìN INICIAL
// =====================================


const { OpenAI } = require('openai');
const pool = require('../../db');
const chatManager = require('../../utils/chatManager');
const admin = require('../../firebase-admin');
const pineconeMemoria = require('../../utils/pinecone');
// Comandos y langfuse removidos - no se usan
require('dotenv').config();
const mapaERP = require('./mapaERP');
// Importaciones desde las carpetas organizadas
const {
    guiaMarkdownCompleta,
    promptGlobal, 
    comportamientoGlobal,
    formatoRespuesta
} = require('../prompts/GLOBAL');

const { sqlRules } = require('../prompts/SQL');

const { identidadEmpresa, terminologia } = require('../prompts/DEITANA');


// =====================================
// FIN DE IMPORTACIONES
// =====================================


// =====================================
// IMPORTACION DE MODULO DE RAG
// =====================================


const ragInteligente = require('../data/integrar_rag_nuevo');


// =====================================
// FIN DE IMPORTACION DE MODULO DE RAG
// =====================================


// =====================================
// CONFIGURACI√ìN DE OPEN AI DESDE LAS VARIABLES DE ENTORNO
// =====================================


const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY
});


// =====================================
// FIN DE CONFIGURACI√ìN DE OPEN AI DESDE LAS VARIABLES DE ENTORNO
// =====================================


// =====================================
//  VARIABLES GLOBALES DE CONTEXTO 
// =====================================


// Historial global de conversaci√≥n (en memoria, para demo)
const conversationHistory = [];
// Contexto de datos reales de la √∫ltima consulta relevante
let lastRealData = null;


// =====================================
// FIN DE VARIABLES GLOBALES DE CONTEXTO
// =====================================









// =====================================
// FUNCI√ìN PARA OBTENER INFORMACI√ìN DEL USUARIO
// =====================================

/**
 * Obtiene la informaci√≥n del usuario desde Firebase incluyendo su displayName
 */
async function obtenerInfoUsuario(userId) {
    try {
        console.log('üë§ [USER-INFO] Obteniendo informaci√≥n del usuario:', userId);
        
        const userRecord = await admin.auth().getUser(userId);
        
        const infoUsuario = {
            uid: userRecord.uid,
            nombre: userRecord.displayName || 'Usuario',
            email: userRecord.email,
            esAdmin: userRecord.customClaims?.isAdmin || false
        };
        
        console.log('‚úÖ [USER-INFO] Informaci√≥n obtenida:', {
            nombre: infoUsuario.nombre,
            email: infoUsuario.email?.substring(0, 3) + '***',
            esAdmin: infoUsuario.esAdmin
        });
        
        return infoUsuario;
    } catch (error) {
        console.error('‚ùå [USER-INFO] Error obteniendo informaci√≥n del usuario:', error.message);
        return {
            uid: userId,
            nombre: 'Usuario',
            email: null,
            esAdmin: false
        };
    }
}














// =====================================
// FUNCI√ìN PARA OBTENER HISTORIAL CONVERSACIONAL
// =====================================

/**
 * Obtiene el historial completo de la conversaci√≥n para contexto
 */
async function obtenerHistorialConversacion(userId, conversationId) {
    try {
        console.log('üìú [HISTORIAL] Obteniendo contexto conversacional...');
        console.log('üìú [HISTORIAL] Usuario:', userId, 'Conversaci√≥n:', conversationId);
        
        if (!conversationId || conversationId.startsWith('temp_')) {
            console.log('üìú [HISTORIAL] Conversaci√≥n temporal/nueva - sin historial previo');
            return [];
        }
        
        const mensajes = await chatManager.getConversationMessages(userId, conversationId);
        
        // Solo tomar los √∫ltimos 6 mensajes para contexto (3 intercambios)
        const mensajesRecientes = mensajes.slice(-6);
        
        console.log(`üìú [HISTORIAL] Obtenidos ${mensajesRecientes.length} mensajes para contexto`);
        
        // Formatear para usar en el prompt
        const contextoFormateado = mensajesRecientes.map(msg => ({
            role: msg.role,
            content: msg.content
        }));
        
        return contextoFormateado;
    } catch (error) {
        console.error('‚ùå [HISTORIAL] Error obteniendo historial:', error.message);
        return [];
    }
}











// =====================================
// PREPARACION DE DATOS SQL PARA FORMATEO POSTERIOR
// =====================================

/**
 * 
 * @param {Array} results - Resultados de la consulta SQL
 * @param {string} query - Consulta original del usuario
 * @returns {string} Respuesta formateada de forma natural
 * 
 */







// =====================================
// EJECUTADOR DE CONSULTAS SQL CON REINTENTOS Y MANEJO DE ERRORES
// =====================================

/**
 * Funci√≥n para ejecutar consultas SQL con sistema inteligente de manejo de errores
 * @param {string} sql - Consulta SQL a ejecutar
 * @param {string} originalQuery - Consulta original del usuario
 * @param {number} attempt - N√∫mero de intento (para reintentos)
 * @returns {Promise<Array>} Resultados de la consulta
 */
async function executeQuery(sql, originalQuery = '', attempt = 1) {
    try {
        // Reemplazar los nombres de las tablas con sus nombres reales
        const sqlModificado = reemplazarNombresTablas(sql);
        console.log(`üîç [SQL-EXEC] Intento ${attempt} - Ejecutando:`, sqlModificado);
        
        const [rows] = await pool.query(sqlModificado);
        console.log('üìä [SQL-RESULT] Filas devueltas:', rows.length);
        
        if (rows.length === 0) {
            console.log('‚ö†Ô∏è [SQL-RESULT] La consulta no devolvi√≥ resultados');
            return [];
        }

        return rows;
        
    } catch (error) {
        console.error(`‚ùå [SQL-EXEC] Error en intento ${attempt}:`, error.message);
        console.error('‚ùå [SQL-EXEC] SQL:', sql);
        
        // Si es posible reintentar y no hemos agotado los intentos
        if (attempt < 3) {
            console.log(`üîÑ [RETRY] Reintentando consulta...`);
            return await executeQuery(sql, originalQuery, attempt + 1);
        }
        
        // Si llegamos aqu√≠, el error no se pudo resolver
        throw error;
    }
}












// =====================================
// VALIDACI√ìN Y PROCESAMIENTO DE SQL
// =====================================


/**
 * Funci√≥n para validar que la respuesta contiene una consulta SQL v√°lida
 * Extrae SQL de diferentes formatos y valida su sintaxis
 * 
 * @param {string} response - Respuesta de OpenAI
 * @returns {string|null} SQL validado o null si no es v√°lido
 * 
 * FORMATOS SOPORTADOS:
 * - <sql>SELECT...</sql>
 * - ```sql SELECT...```
 * - SELECT... (texto plano)
 */
function validarRespuestaSQL(response) {
    console.log('üîç [SQL-VALIDATION] Validando respuesta para extraer SQL...');
    
    const sqlQueries = [];
    
    // Buscar m√∫ltiples consultas SQL con etiquetas <sql>
    const sqlMatches = response.match(/<sql>([\s\S]*?)<\/sql>/g);
    if (sqlMatches) {
        console.log('‚úÖ [SQL-VALIDATION] Encontradas', sqlMatches.length, 'consultas SQL con etiquetas');
        sqlMatches.forEach((match, index) => {
            const sqlContent = match.replace(/<\/?sql>/g, '').trim();
            if (sqlContent && sqlContent.toLowerCase().startsWith('select')) {
                sqlQueries.push(procesarSQL(sqlContent, `SQL ${index + 1}`));
            }
        });
    }
    
    // Si no encontr√≥ con etiquetas, buscar con bloques de c√≥digo SQL
    if (sqlQueries.length === 0) {
        const codeMatches = response.match(/```sql\s*([\s\S]*?)```/g);
        if (codeMatches) {
            console.log('‚úÖ [SQL-VALIDATION] Encontradas', codeMatches.length, 'consultas SQL en bloques de c√≥digo');
            codeMatches.forEach((match, index) => {
                const sqlContent = match.replace(/```sql\s*/, '').replace(/```/, '').trim();
                if (sqlContent && sqlContent.toLowerCase().startsWith('select')) {
                    sqlQueries.push(procesarSQL(sqlContent, `SQL ${index + 1}`));
                }
            });
        }
    }
    
    // Si no encontr√≥ con bloques, buscar SQL en texto plano
    if (sqlQueries.length === 0) {
        console.log('üîç [SQL-VALIDATION] Buscando SQL en texto plano...');
        const sqlPattern = /(SELECT\s+[\s\S]*?)(?:;|$)/gi;
        let match;
        let index = 0;
        while ((match = sqlPattern.exec(response)) !== null) {
            const sqlContent = match[1].trim();
            if (sqlContent && sqlContent.toLowerCase().startsWith('select')) {
                sqlQueries.push(procesarSQL(sqlContent, `SQL ${index + 1}`));
                index++;
            }
        }
        if (sqlQueries.length > 0) {
            console.log('‚úÖ [SQL-VALIDATION] Encontradas', sqlQueries.length, 'consultas SQL en texto plano');
        }
    }
    
    if (sqlQueries.length === 0) {
        console.log('‚ùå [SQL-VALIDATION] No se encontr√≥ SQL en la respuesta');
        return null;
    }
    
    // Si solo hay una consulta, devolverla como string (compatibilidad)
    if (sqlQueries.length === 1) {
        return sqlQueries[0];
    }
    
    // Si hay m√∫ltiples consultas, devolver array
    console.log('‚úÖ [SQL-VALIDATION] Devolviendo', sqlQueries.length, 'consultas SQL');
    return sqlQueries;
}

function procesarSQL(sql, nombre) {
    console.log(`üîç [SQL-PROCESSING] Procesando ${nombre}:`, sql.substring(0, 100) + '...');
    
    // Validar que es una consulta SQL v√°lida
    if (!sql.toLowerCase().startsWith('select')) {
        console.error(`‚ùå [SQL-PROCESSING] ${nombre} no es SELECT`);
        throw new Error(`${nombre} debe comenzar con SELECT`);
    }
    
    // Validar y corregir sintaxis com√∫n
    if (sql.includes('OFFSET')) {
        const offsetMatch = sql.match(/LIMIT\s+(\d+)\s+OFFSET\s+(\d+)/i);
        if (offsetMatch) {
            sql = sql.replace(
                /LIMIT\s+(\d+)\s+OFFSET\s+(\d+)/i,
                `LIMIT ${offsetMatch[2]}, ${offsetMatch[1]}`
            );
            console.log(`üîÑ [SQL-PROCESSING] Corregida sintaxis OFFSET en ${nombre}`);
        }
    }
    
    // Verificar si es una consulta de conteo
    const esConsultaConteo = sql.toLowerCase().includes('count(*)');
    const tieneDistinct = /select\s+distinct/i.test(sql);
    const tieneGroupBy = /group by/i.test(sql);
    const tieneJoin = /join/i.test(sql);
    const tieneFiltroFecha = /where[\s\S]*fpe_fec|where[\s\S]*fecha|where[\s\S]*_fec/i.test(sql);
    
    // Si no tiene LIMIT y no es excepci√≥n, AGREGAR LIMIT autom√°ticamente
    if (!esConsultaConteo && !tieneDistinct && !tieneGroupBy && !sql.toLowerCase().includes('limit') && !(tieneJoin && tieneFiltroFecha)) {
        sql = sql.replace(/;*\s*$/, '');
        sql += ' LIMIT 10';
        console.log(`üîÑ [SQL-PROCESSING] Agregado LIMIT autom√°tico en ${nombre}`);
    }
    
    console.log(`‚úÖ [SQL-PROCESSING] ${nombre} validado:`, sql.substring(0, 100) + '...');
    return sql;
}


















// =====================================
// REEMPLAZAR DE TABLAS CON NOMBRES REALES
// =====================================

// Funci√≥n para reemplazar nombres de tablas en la consulta SQL
function reemplazarNombresTablas(sql) {
    let sqlModificado = sql;
    Object.keys(mapaERP).forEach(key => {
        if (mapaERP[key].tabla && mapaERP[key].tabla.includes('-')) {
            const regex = new RegExp(`\\b${key}\\b`, 'g');
            sqlModificado = sqlModificado.replace(regex, `\`${mapaERP[key].tabla}\``);
        }
    });
    return sqlModificado;
}

















// =====================================
// CONSTRUCCI√ìN INTELIGENTE DE PROMPTS
// =====================================

/**
 * Construye un prompt optimizado usando IA inteligente (UNA SOLA LLAMADA)
 * Esta es la funci√≥n principal que orquesta todo el proceso de construcci√≥n
 * 
 * @param {string} mensaje - Consulta del usuario
 * @param {Object} mapaERP - Mapa de estructura de la base de datos
 * @param {Object} openaiClient - Cliente de OpenAI
 * @param {string} contextoPinecone - Contexto de memoria vectorial
 * @param {string} contextoDatos - Datos de contexto previo
 * @param {boolean} modoDesarrollo - Modo de desarrollo para debugging
 * @returns {Object} Prompt construido con configuraci√≥n y m√©tricas
 */
async function construirPromptInteligente(mensaje, mapaERP, openaiClient, contextoPinecone = '', contextoDatos = '', historialConversacion = [], modoDesarrollo = false) {
    console.log('üöÄ [PROMPT-BUILDER] Construyendo prompt ULTRA-OPTIMIZADO...');
    
    // =====================================
    // AN√ÅLISIS DE INTENCI√ìN Y CONFIGURACI√ìN
    // =====================================
    
    // 1. AN√ÅLISIS INTELIGENTE R√ÅPIDO (SIN LLAMADAS IA)
    const intencion = await analizarIntencionInteligente(mensaje);
    console.log('üéØ [PROMPT-BUILDER] Intenci√≥n detectada:', intencion);
    
    // 2. Configuraci√≥n del modelo (siempre gpt-4o)
    const configModelo = {
        modelo: 'gpt-4o',
        maxTokens: 3000,
        temperature: 0.9,
        topP: 0.95,
        frequencyPenalty: 0.5,
        presencePenalty: 0.4
    };



     // =====================================
    // RECOLECCI√ìN DE INFORMACI√ìN
    // =====================================
    
    // 3. SIEMPRE incluir mapaERP - la IA decide si lo usa
    const contextoMapaERP = construirContextoMapaERPCompleto(mapaERP);
    console.log('üìã [MAPA-ERP] Incluyendo mapaERP completo - IA decide si lo usa');
    
    // 4. Construir instrucciones naturales
    const instruccionesNaturales = construirInstruccionesNaturales(intencion, [], contextoPinecone);
    console.log(`üîç [DEBUG-PROMPT] Intenci√≥n final: ${JSON.stringify(intencion)}`);
    console.log(`üîç [DEBUG-PROMPT] Instrucciones naturales construidas: ${instruccionesNaturales.length} caracteres`);
    
    // 5. RAG INTELIGENTE Y SELECTIVO (OPTIMIZADO)
    let contextoRAG = '';
    
    // RAG SIEMPRE ACTIVO para evitar alucinaciones
    try {
        console.log('üß† [RAG] Recuperando conocimiento empresarial...');
        contextoRAG = await ragInteligente.recuperarConocimientoRelevante(mensaje, 'sistema');
        console.log('‚úÖ [RAG] Conocimiento recuperado:', contextoRAG ? contextoRAG.length : 0, 'caracteres');
    } catch (error) {
        console.error('‚ùå [RAG] Error recuperando conocimiento:', error.message);
        // Continuar sin RAG si hay error, pero registrar el problema
    }
    












    // =====================================
// ENSAMBLAJE DEL PROMPT FINAL
// =====================================
    
    // 6. Preparar la fecha actual para el prompt
    const fechaActual = new Date().toLocaleString('es-ES', { timeZone: 'Europe/Madrid', dateStyle: 'full', timeStyle: 'short' });
    
    // 7. Crear el prompt base (como el encabezado de una carta)
    const promptGlobalConFecha = promptGlobal.replace('{{FECHA_ACTUAL}}', fechaActual);
    
    // 8. Empezar a construir el prompt final (como empezar a escribir la carta)
    let promptFinal = `${promptGlobalConFecha}\n` + instruccionesNaturales;
    
    // 9. Si encontramos informaci√≥n de la empresa, ponerla AL PRINCIPIO (como informaci√≥n importante)
    if (contextoRAG) {
        console.log('üéØ [RAG] PRIORIZANDO contexto empresarial al inicio');
        // Reconstruir el prompt poniendo la informaci√≥n de la empresa al principio
        promptFinal = `${promptGlobalConFecha}\n\nCONOCIMIENTO EMPRESARIAL ESPEC√çFICO:\n${contextoRAG}\n\nINSTRUCCI√ìN: Debes usar siempre la informaci√≥n del conocimiento empresarial espec√≠fico proporcionado arriba. Si la informaci√≥n est√° disponible en ese contexto, √∫sala. No des respuestas gen√©ricas cuando tengas informaci√≥n espec√≠fica de la empresa.\n\n` + instruccionesNaturales;
    }
    
    // 10. Agregar la estructura de la base de datos (como un mapa de la ciudad)
    promptFinal += `${contextoMapaERP}\n\n`;
    
    // 11. Solo agregar reglas SQL si la consulta necesita datos (como reglas de tr√°fico solo si vas a manejar)
    if (intencion.tipo === 'sql' || intencion.tipo === 'rag_sql') {
        promptFinal += `${sqlRules}\n\n`;
    }
    
    // 12. Agregar datos de consultas anteriores si existen (como recordar lo que hablamos antes)
    if (contextoDatos) {
        promptFinal += `DATOS DE CONTEXTO PREVIO:\n${contextoDatos}\n\n`;
    }
    
    // 13. Agregar conversaci√≥n reciente si existe (como recordar los √∫ltimos mensajes)
    if (historialConversacion && historialConversacion.length > 0) {
        const ultimosMensajes = historialConversacion.slice(-4); // Solo los √∫ltimos 4 mensajes
        const contextoConversacional = ultimosMensajes.map(msg => 
            `${msg.role === 'user' ? 'Usuario' : 'Asistente'}: ${msg.content}`
        ).join('\n');
        
        // Agregar el contexto conversacional al prompt final
        promptFinal += `## üí¨ CONTEXTO CONVERSACIONAL RECIENTE\n\n${contextoConversacional}\n\n## üéØ INSTRUCCIONES DE CONTINUIDAD\n\n- Mant√©n la continuidad natural de la conversaci√≥n\n- NO te presentes de nuevo si ya has saludado\n- Usa el contexto previo para dar respuestas coherentes\n- Si el usuario hace referencia a algo mencionado antes, √∫salo\n- Mant√©n el tono y estilo de la conversaci√≥n en curso\n\n`;
    }
    
    console.log('‚úÖ [PROMPT-BUILDER] Prompt construido - MapaERP: SIEMPRE, RAG: SIEMPRE');





// RETORNO DE RESULTADOS
// =====================================
    
    return {
        prompt: promptFinal,
        configModelo: configModelo,
        intencion: intencion,
        tablasRelevantes: [], // IA analiza todas las tablas del mapaERP
        metricas: {
            usaIA: true, // IA analiza mapaERP completo
            tablasDetectadas: Object.keys(mapaERP).length,
            llamadasIA: 1, // ¬°Solo UNA llamada!
            optimizado: true,
            modeloUnico: 'gpt-4o',
            mapaERPIncluido: true, // SIEMPRE incluido
            ragIncluido: true // SIEMPRE incluido para evitar alucinaciones
        }
    };
}









































// =====================================
// AN√ÅLISIS INTELIGENTE DE INTENCIONES
// =====================================

/**
 * Analiza la intenci√≥n usando IA real (escalable para 900 tablas y 200 usuarios)
 */
async function analizarIntencionInteligente(mensaje) {
    console.log('üß† [INTENCION-IA] Analizando consulta con IA real...');
    
    try {
        // Usar IA para analizar la intenci√≥n de forma inteligente
        const promptAnalisis = `Analiza la siguiente consulta y determina qu√© tipo de respuesta necesita:

CONSULTA: "${mensaje}"

OPCIONES:
1. "sql" - Si la consulta pide datos, n√∫meros, conteos, listas, informaci√≥n de la base de datos
2. "conocimiento" - Si la consulta pide explicaciones, definiciones, protocolos, informaci√≥n del archivo .txt  
3. "conversacion" - Si es un saludo, agradecimiento, o conversaci√≥n casual

REGLAS INTELIGENTES:

üîç ES SQL SI:
- Pide DATOS espec√≠ficos (n√∫meros, cantidades, listas)
- Usa palabras como: "cu√°ntos", "dame", "lista de", "muestra", "busca"
- Menciona ENTIDADES de base de datos (clientes, productos, ventas, etc.)
- Pide informaci√≥n que requiere CONSULTAR datos
- Incluye filtros (por fecha, ubicaci√≥n, tipo, etc.)

üìö ES CONOCIMIENTO SI:
- Pide EXPLICACIONES o DEFINICIONES
- Usa palabras como: "qu√© es", "c√≥mo funciona", "explica", "significa"
- Pregunta sobre PROCESOS o PROTOCOLOS
- Busca informaci√≥n conceptual o te√≥rica

üí¨ ES CONVERSACI√ìN SI:
- Saludos, despedidas, agradecimientos
- Charla casual sin solicitud espec√≠fica de datos

‚ö° PRINCIPIO CLAVE: Si hay DUDA, es probablemente SQL (la mayor√≠a de consultas en ERP piden datos)

Analiza la INTENCI√ìN SEM√ÅNTICA, no palabras espec√≠ficas.

Responde SOLO con: sql, conocimiento, o conversacion`;

        const response = await openai.chat.completions.create({
            model: 'gpt-4o-mini',
            messages: [{ role: 'user', content: promptAnalisis }],
            max_tokens: 10,
            temperature: 0.1
        });

        const tipo = response.choices[0].message.content.trim().toLowerCase();
        console.log(`‚úÖ [INTENCION-IA] Tipo detectado: ${tipo}`);
        console.log(`üîç [INTENCION-IA] Mensaje original: "${mensaje}"`);
        console.log(`üîç [INTENCION-IA] Respuesta completa: "${response.choices[0].message.content}"`);

        // Mapear a tipos internos
        if (tipo === 'sql') {
            return { tipo: 'sql', confianza: 0.95 };
        } else if (tipo === 'conocimiento') {
            return { tipo: 'rag_sql', confianza: 0.95 };
        } else {
            return { tipo: 'conversacion', confianza: 0.95 };
        }
        
    } catch (error) {
        console.error('‚ùå [INTENCION-IA] Error:', error.message);
        // Fallback inteligente: si tiene signo de interrogaci√≥n, probablemente necesita datos
        if (mensaje.toLowerCase().includes('?')) {
            return { tipo: 'sql', confianza: 0.7 };
        }
        return { tipo: 'conversacion', confianza: 0.5 };
    }
}











































































// =====================================
// FUNCI√ìN PARA PERSONALIZAR RESPUESTA CON NOMBRE
// =====================================

/**
 * Personaliza la respuesta incluyendo el nombre del usuario de forma sutil
 */
function personalizarRespuesta(respuesta, nombreUsuario) {
    // No personalizar si es un nombre gen√©rico
    if (!nombreUsuario || nombreUsuario === 'Usuario' || nombreUsuario.length < 2) {
        return respuesta;
    }
    
    console.log(`üé® [PERSONALIZACI√ìN] Personalizando respuesta para ${nombreUsuario}`);
    
    // Patrones para agregar el nombre de forma sutil (no siempre, aproximadamente 30% de las veces)
    const deberiaPersonalizar = Math.random() < 0.3;
    
    if (!deberiaPersonalizar) {
        console.log('üé® [PERSONALIZACI√ìN] Saltando personalizaci√≥n para esta respuesta');
        return respuesta;
    }
    
    const patronesPersonalizacion = [
        // Al inicio de la respuesta
        {
            patron: /^¬°?Hola[!,]?\s*/i,
            reemplazo: `¬°Hola, ${nombreUsuario}! `
        },
        {
            patron: /^Perfecto[!,]?\s*/i,
            reemplazo: `Perfecto, ${nombreUsuario}. `
        },
        // En medio de la respuesta
        {
            patron: /¬øTe sirve esta informaci√≥n\?/i,
            reemplazo: `¬øTe sirve esta informaci√≥n, ${nombreUsuario}?`
        },
        {
            patron: /¬øNecesitas algo m√°s\?/i,
            reemplazo: `¬øNecesitas algo m√°s, ${nombreUsuario}?`
        },
        // Al final de la respuesta
        {
            patron: /¬øEn qu√© m√°s puedo ayudarte\?/i,
            reemplazo: `¬øEn qu√© m√°s puedo ayudarte, ${nombreUsuario}?`
        }
    ];
    
    // Aplicar un patr√≥n aleatorio que coincida
    for (const { patron, reemplazo } of patronesPersonalizacion) {
        if (patron.test(respuesta)) {
            const respuestaPersonalizada = respuesta.replace(patron, reemplazo);
            console.log('‚úÖ [PERSONALIZACI√ìN] Respuesta personalizada aplicada');
            return respuestaPersonalizada;
        }
    }
    
    // Si no coincide ning√∫n patr√≥n, agregar el nombre al final de forma sutil
    if (respuesta.endsWith('?')) {
        return respuesta.slice(0, -1) + `, ${nombreUsuario}?`;
    } else if (respuesta.endsWith('.')) {
        return respuesta.slice(0, -1) + `, ${nombreUsuario}.`;
    }
    
    console.log('üé® [PERSONALIZACI√ìN] No se aplic√≥ personalizaci√≥n espec√≠fica');
    return respuesta;
}




























































































































// =====================================
// GUARDA MENSAJES EN FIREBASE Y GUARDA RESPUESTA DEL ASISTENTE EN FIRESTORE
// =====================================



async function saveMessageToFirestore(userId, message, isAdmin = true) {
    try {
        const now = new Date();
        const messageData = {
            content: message,
            role: 'user',
            timestamp: now
        };

        const userChatRef = chatManager.chatsCollection.doc(userId);
        const conversationRef = userChatRef.collection('conversations').doc('admin_conversation');
        
        // Primero obtenemos el documento actual
        const conversationDoc = await conversationRef.get();
        let messages = [];
        
        if (conversationDoc.exists) {
            messages = conversationDoc.data().messages || [];
        }
        
        // Agregamos el nuevo mensaje
        messages.push(messageData);
        
        // Actualizamos el documento con el nuevo array de mensajes
        await conversationRef.set({
            lastUpdated: now,
            messages: messages
        }, { merge: true });

        return true;
    } catch (error) {
        console.error('Error al guardar mensaje en Firestore:', error);
        return false;
    }
}

// Funci√≥n para guardar mensaje del asistente en Firestore
async function saveAssistantMessageToFirestore(userId, message) {
    try {
        const now = new Date();
        const messageData = {
            content: message,
            role: 'assistant',
            timestamp: now
        };

        const userChatRef = chatManager.chatsCollection.doc(userId);
        const conversationRef = userChatRef.collection('conversations').doc('admin_conversation');
        
        // Primero obtenemos el documento actual
        const conversationDoc = await conversationRef.get();
        let messages = [];
        
        if (conversationDoc.exists) {
            messages = conversationDoc.data().messages || [];
        }
        
        // Agregamos el nuevo mensaje
        messages.push(messageData);
        
        // LIMITAR EL TAMA√ëO DE LA CONVERSACI√ìN PARA EVITAR ERRORES DE FIRESTORE
        const MAX_MESSAGES = 30; // M√°ximo 30 mensajes por conversaci√≥n
        const MAX_MESSAGE_SIZE = 50000; // M√°ximo 50KB por mensaje
        
        // Si el mensaje es muy grande, truncarlo
        if (messageData.content.length > MAX_MESSAGE_SIZE) {
            console.log(`‚ö†Ô∏è [FIRESTORE] Mensaje muy grande (${messageData.content.length} chars), truncando...`);
            messageData.content = messageData.content.substring(0, MAX_MESSAGE_SIZE) + '\n\n[Contenido truncado por l√≠mite de tama√±o]';
        }
        
        // Si hay demasiados mensajes, mantener solo los √∫ltimos MAX_MESSAGES
        if (messages.length > MAX_MESSAGES) {
            console.log(`‚ö†Ô∏è [FIRESTORE] Demasiados mensajes (${messages.length}), manteniendo √∫ltimos ${MAX_MESSAGES}...`);
            messages = messages.slice(-MAX_MESSAGES);
        }
        
        // Calcular tama√±o aproximado del documento
        const documentSize = JSON.stringify({
            lastUpdated: now,
            messages: messages
        }).length;
        
        if (documentSize > 900000) { // 900KB como margen de seguridad
            console.log(`‚ö†Ô∏è [FIRESTORE] Documento muy grande (${documentSize} bytes), limpiando conversaci√≥n...`);
            // Mantener solo los √∫ltimos 10 mensajes
            messages = messages.slice(-10);
        }
        
        // Actualizamos el documento con el nuevo array de mensajes
        await conversationRef.set({
            lastUpdated: now,
            messages: messages
        }, { merge: true });

        console.log(`‚úÖ [FIRESTORE] Mensaje guardado. Total mensajes: ${messages.length}`);
        return true;
    } catch (error) {
        console.error('Error al guardar mensaje del asistente en Firestore:', error);
        
        // Si el error es por tama√±o, intentar limpiar la conversaci√≥n
        if (error.message && error.message.includes('exceeds the maximum allowed size')) {
            console.log('üîÑ [FIRESTORE] Intentando limpiar conversaci√≥n por tama√±o...');
            try {
                const userChatRef = chatManager.chatsCollection.doc(userId);
                const conversationRef = userChatRef.collection('conversations').doc('admin_conversation');
                
                // Crear nueva conversaci√≥n con solo el mensaje actual
                await conversationRef.set({
                    lastUpdated: new Date(),
                    messages: [{
                        content: message.length > 50000 ? message.substring(0, 50000) + '\n\n[Contenido truncado]' : message,
                        role: 'assistant',
                        timestamp: new Date()
                    }]
                });
                
                console.log('‚úÖ [FIRESTORE] Conversaci√≥n limpiada exitosamente');
                return true;
            } catch (cleanupError) {
                console.error('‚ùå [FIRESTORE] Error limpiando conversaci√≥n:', cleanupError);
                return false;
            }
        }
        
        return false;
    }
}


































// =====================================
// LOGS DE MANTEMINIENTO
// =====================================

function performSystemMaintenance() {
    console.log('üßπ [MAINTENANCE] Iniciando mantenimiento del sistema...');
    
    // Log de mantenimiento b√°sico
    console.log('üìä [MAINTENANCE] Sistema funcionando correctamente');
    
    return {
        status: 'ok',
        message: 'Mantenimiento completado'
    };
}

// Ejecutar mantenimiento cada hora
setInterval(performSystemMaintenance, 60 * 60 * 1000);
